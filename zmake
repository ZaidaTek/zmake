#!/usr/bin/python3

 ### Copyright (C) 2025 ZaidaTek and Andreas Riebesehl
#### This work is licensed under: Creative Commons Attribution-NoDerivatives 4.0 International Public License
#### For full license text, please visit: https://creativecommons.org/licenses/by-nd/4.0/legalcode
###

 ### !!! NOTE (2025-08-17) !!!
#### !!! THIS IS EXPERIMENTAL SOFTWARE, ABSOLUTELY NO WARRANTIES OR GUARANTEES ARE PROVIDED WHATSOEVER IN ANY FORM !!!
#### !!! ITS EXECUTION INCLUDES POSSIBLY USING e.g. "rm CALCULATED_FILEPATH" FOR CLEANING OBJECTS FILES, YOU HAVE BEEN WARNED !!!
###

import sys, os, subprocess, getopt, json

## "#DEFINES", TODO externalize user-definables to ZMK_APP
ZMK_CONST = {
    "zmake": "250830", # THIS IS (INTENTIONALLY) VERSION
    "encoding": "utf-8",
    "arg_short": "fnyxcqzvh",
    "arg_long": ["version", "help", "dry"],
    "host": [
        ["date"],
        ["zmake", "--version"],
        ["neofetch", "--stdout"],
        ["gcc", "--version"],
        ["g++", "--version"]
    ],
    "sign": [
        ["md5sum"],
        ["sha1sum"],
        ["sha256sum"]
    ],
    "help": "--TEXT--\n--TEXT--\n--TEXT--"
}
## APPLICATION SETTINGS, TODO zmake.jsonf
ZMK_APP = {
    "compiler": {
        "gcc": {"command": ["gcc"], "type": [".c"]},
        "g++": {"command": ["g++"], "type": [".cpp", ".c"]}
    },
    "linker": {
        "gcc": {"command": ["gcc"], "type": [".c.o"]},
        "g++": {"command": ["g++"], "type": [".cpp.o", ".c.o"]}
    },
    "set": {
        "dry": True,
        "force": False,
        "exec": False,
        "clean": False,
        "log": True,
        "sign": False
    }
}
## GLOBAL MAKE ENVIRONMENT, TODO zmake.zmk
ZMK_MAKE = {
    "flag": {
        "shared": ["-flto", "-O3"],
        "compiler": ["-fexpensive-optimizations"],
        "linker": ["-s"],
        "extra": {
            "shared": [],
            "compiler": ["-Wfatal-errors", "-Werror", "-Wall", "-Wextra"],
            "linker": []
        }
    }
}
## UTIL FUNCTIONS
def ZMK_UtilExec(iCommand, iCapture = True, iEncoding = ZMK_CONST["encoding"]):
    return subprocess.run(iCommand, capture_output = iCapture, encoding = iEncoding)
def ZMK_UtilPathExpand(iPath):
    return os.path.expanduser(os.path.normpath(iPath))
def ZMK_UtilPathMakeTarget(iPathTarget, iMakeRoot):
    return ZMK_UtilPathExpand(iPathTarget if os.path.isabs(iPathTarget) else os.path.join(iMakeRoot, iPathTarget))
def ZMK_UtilFileScan(iPathDir, iFileExtensions):
    lTargets = []
    for lScanRoot, lScanDirs, lScanFiles in os.walk(iPathDir):
        for x in lScanFiles:        
            if os.path.splitext(x)[1] in iFileExtensions:
                lTargets.append(os.path.join(lScanRoot, x))
    return lTargets
def ZMK_UtilJSONLoad(iPath):
    try:
        with open(iPath, "r", encoding = ZMK_CONST["encoding"]) as lFile:
            lData = json.load(lFile)
    except:
        print(f"zmake-err: opening {iPath}")
        exit(0x1)
    return lData
def ZMK_UtilJSONSave(iPath, iData):
    try:
        with open(iPath, "w", encoding = ZMK_CONST["encoding"]) as lFile:
            json.dump(iData, lFile, indent = 4, ensure_ascii = False)
    except:
        print(f"zmake-err: writing {iPath}")
        exit(0x1)
## ZMAKE FUNCTIONS
def ZMK_MakeLoad(iPath, iData):
    lPathRoot = ZMK_UtilPathExpand(iPath if os.path.isdir(iPath) else os.path.dirname(iPath))
    lBaseTarget = ZMK_UtilPathExpand(iData.get("target", os.path.splitext(os.path.basename(lPathRoot))[0]))
    iData["target"] = ZMK_UtilPathMakeTarget(lBaseTarget, lPathRoot)
    iData.setdefault("zmake", ZMK_MAKE.get("zmake", ZMK_CONST["zmake"]))
    iData["host"] = ZMK_APP["host"].copy()
    # if "sources" in iData:
    if isinstance(iData["sources"], list):
        lCache = [ZMK_UtilPathMakeTarget(x, lPathRoot) for x in iData["sources"]]
        iData["sources"] = {}
        for x in lCache:
            iData["sources"][x] = {}
    elif isinstance(iData["sources"], dict):
        for x in [x for x in iData["sources"].keys()]:
            iData["sources"][ZMK_UtilPathMakeTarget(x, lPathRoot)] = iData["sources"].pop(x)
    # else:
        # for x in ZMK_UtilFileScan(lPathRoot, ZMK_CONST["type_c"] + ZMK_CONST["type_cpp"]):
            # iData.setdefault("sources", {})[x] = {}
    if "include" in iData:
        iData["include"] = [ZMK_UtilPathMakeTarget(x, lPathRoot) for x in iData["include"]]
    return iData
def ZMK_MakeCommand(iData, iContexts):
    for lContext in iContexts:
        lTarget = iData.setdefault("commands", {}).setdefault(lContext, [])
        if lContext == "compile":
            # TODO analysis should be in ZMK_MakeLoad
            for lPathSource, lOptionsSource in iData["sources"].items():
                lPathObject = f"{lPathSource}.o"
                lOptionsObject = {}
                iData.setdefault("objects", {})[lPathObject] = lOptionsObject
                for lName, lCapabilities in ZMK_APP["compiler"].items():
                    if os.path.splitext(lPathSource)[1] in lCapabilities["type"]:
                        lOptionsSource["handle"] = lName
                        break
                if not "handle" in lOptionsSource and not lOptionsSource["handle"]:
                    print("zmake-err: unknown source type")
                    exit(0x1)
                lTemplate = [] + ZMK_APP["compiler"][lOptionsSource["handle"]]["command"]
                for x in (("compiler", "shared")):
                    lTemplate += lOptionsSource.get("flag", {}).get(x, iData.get("flag", {}).get(x, ZMK_MAKE["flag"][x]))
                for x in ((lOptionsSource, iData, ZMK_MAKE)):
                    lTemplate += x.get("flag", {}).get("extra", {}).get("shared", [])
                    lTemplate += x.get("flag", {}).get("extra", {}).get("compiler", [])
                lTemplate += [f"-I{x}" for x in iData.get("include", [])]
                lTemplate += ["-c", lPathSource, "-o", lPathObject]
                lTarget.append(lTemplate)
        elif lContext == "link":
            lLinkers = []
            # TODO analysis should be in ZMK_MakeLoad
            for lPathObject, lOptionsObject in iData.get("objects", {}).items():
                for lName, lCapabilities in ZMK_APP["linker"].items():
                    lExtRoot, lExtLast = os.path.splitext(lPathObject)
                    if (os.path.splitext(lExtRoot)[1] + lExtLast) in lCapabilities["type"]:
                        lOptionsObject["handle"] = lName
                        if lName not in lLinkers:
                            lLinkers.append(lName)
                        break
                if not "handle" in lOptionsObject and not lOptionsObject["handle"]:
                    print("zmake-err: unknown object type")
                    exit(0x1)
            # TODO when cpp is involved
            lTemplate  = ZMK_APP["linker"][lLinkers[0]]["command"] + list(iData.get("objects", {}).keys()) + ["-o", iData["target"]]
            lTemplate += iData.get("flag", {}).get("shared", ZMK_MAKE["flag"]["shared"])
            lTemplate += iData.get("flag", {}).get("linker", ZMK_MAKE["flag"]["linker"])
            for x in ((iData, ZMK_MAKE)):
                lTemplate += x.get("flag", {}).get("extra", {}).get("shared", [])
                lTemplate += x.get("flag", {}).get("extra", {}).get("linker", [])
            lTemplate += [f"-l{x}" for x in iData.get("link", [])]
            lTemplate += [f"-L{x}" for x in iData.get("include", [])]
            lTarget.append(lTemplate)
        elif lContext == "clean":
            if ZMK_APP["set"]["clean"]:
                # lTarget.extend(["rm", x] for x in list(iData.get("objects", {}).keys()))
                lTarget.append(["rm"] + list(iData.get("objects", {}).keys()))
        elif lContext == "finish":
            if ZMK_APP["set"]["exec"]:
                lTarget.append(["chmod", "+x", iData["target"]])
        else:
            pass
    return iData
## __MAIN__ FUNCTION
def ZMK_Main(iArgs):
    ## USER OPTIONS
    try:
        lArgUser = getopt.gnu_getopt(iArgs[1:], ZMK_CONST["arg_short"], longopts=ZMK_CONST["arg_long"])
    except getopt.GetoptError as lError:
        print(lError)
        exit(0x1)
    for lKey, lValue in lArgUser[0]:
        if lKey == "-v" or lKey == "--version":
            print(f"zmake-wrn: version\n{ZMK_CONST['zmake']}")
            exit(0x0)
        elif lKey == "-h" or lKey == "--help":
            print(f"zmake-wrn: help\n{ZMK_CONST['help']}")
            exit(0x0)
        elif lKey == "-n" or lKey == "--dry":
            ZMK_APP["set"]["dry"] = True
        elif lKey == "-y":
            ZMK_APP["set"]["dry"] = False
        elif lKey == "-f":
            ZMK_APP["set"]["force"] = True # TODO implement me!
        elif lKey == "-x":
            ZMK_APP["set"]["exec"] = True
        elif lKey == "-c":
            ZMK_APP["set"]["clean"] = True
        elif lKey == "-q":
            ZMK_APP["set"]["log"] = False
        elif lKey == "-z":
            ZMK_APP["set"]["sign"] = True
    ## HOST
    for lCommand in ZMK_CONST["host"]:
        lProcess = ZMK_UtilExec(lCommand)
        if lProcess.returncode != 0x0:
            print(f"zmake-err: failed command {lProcess.args}")
            exit(0x1)
        ZMK_APP.setdefault("host", {})[str(lProcess.args)] = [x for x in lProcess.stdout.split("\n") if x]
    ## PARSE
    if lArgUser[1]:
        lTargets = [[x, {} if os.path.isdir(x) else ZMK_UtilJSONLoad(x)] for x in lArgUser[1]]
    else:
        # lTargets = [[iArgs[0], {}]]
        print("zmake-err: no zmake .zmk file provided")
        exit(0x1)
    for lPathMake, lMake in lTargets:
        ZMK_MakeLoad(lPathMake, lMake)
        ZMK_MakeCommand(lMake, ["compile", "link", "clean", "finish"])
        for lType, lList in lMake.get("commands", []).items():
            for lCommand in lList:
                lPrint = " ".join([(f"\"{x}\"" if " " in x else x) for x in lCommand]) # NOTE: otherwise commands break if path contains space and clipboard-copied by user
                print(f"zmake-cmd: {lPrint}")
                if not ZMK_APP["set"]["dry"]:
                    lHalt = ZMK_UtilExec(lCommand, False).returncode # NOTE: subprocess args are list, not string and space-delimited
                    if lHalt != 0x0:
                        print(f"zmake-err: non-zero subprocess exit code {lHalt}")
                        exit(lHalt)
        if ZMK_APP["set"]["sign"] and not ZMK_APP["set"]["dry"]:
            if os.path.exists(lMake["target"]):
                lMake["sign"] = {}
                for lCommand in ZMK_CONST["sign"]:
                    lProcess = ZMK_UtilExec(lCommand + [lMake["target"]])
                    if lProcess.returncode != 0x0:
                        print(f"zmake-err: failed command {lProcess.args}")
                        exit(0x1)
                    lMake["sign"][str(lProcess.args)] = [x for x in lProcess.stdout.split(" ", 1)[0].split("\n") if x]
        if ZMK_APP["set"]["log"] and not ZMK_APP["set"]["dry"]:
            ZMK_UtilJSONSave(f"{lPathMake}.log", lMake)
## __MAIN__ INIT
if __name__ == "__main__":
    ZMK_Main(sys.argv)
    exit(0x0)
